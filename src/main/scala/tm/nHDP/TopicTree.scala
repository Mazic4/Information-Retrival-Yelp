package tm.nHDP

import tm.util.Tree
import scala.annotation.tailrec

case class TopicBase(index: Int, count: Double, words: Vector[String])
case class Topic(index: Int, count: Double, level: Int, words: Vector[String])

/**
 * Provides functions for building a topic tree generated by nHDP.
 */
object TopicTree {
  val nodeLineRegex = """(?:ThisNode|Parent|Child \d+) :Index (\d+) Count ([0-9\.]+)""".r

  case class Node(topic: TopicBase, parent: Option[Int], children: Seq[Int])

  def read(lines: List[String]): List[Tree[Topic]] = {
    val nodes = readNodes(lines)
    val groups = nodes.groupBy(_.parent)

    val roots = groups.getOrElse(None, List.empty)
    val childrenMap = groups.collect(
      _ match { case (Some(i), value) => (i, value) })

    val baseTrees = roots.map(buildTree(_, childrenMap))
    val levels = Tree.findLevels(baseTrees)
    baseTrees.map(_.map(t => Topic(t.index, t.count, levels(t), t.words)))
  }

  def readNodes(lines: List[String]): List[Node] = {
    @tailrec
    def rec(nodes: List[Node], lines: List[String]): List[Node] = {
      if (lines.size == 0)
        return nodes.reverse

      // find the next "this node" line, which indicates the end of the previous
      // node
      val splitIndex = lines.indexOf("*** This node ***")
      val (nodeLines, remainingLines) = if (splitIndex >= 0) {
        val (l1, l2) = lines.splitAt(splitIndex)
        (l1, l2.drop(1)) // first line of l2 is "*** This node ***"
      } else
        (lines, List.empty[String])

      if (nodeLines.size <= 1)
        rec(nodes, remainingLines)
      else {
        rec(readNode(nodeLines) :: nodes, remainingLines)
      }
    }

    rec(List.empty, lines)

  }

  /**
   * Example:
   *
   *
   * ThisNode :Index 1 Count 9702.363492
   * article
   * cs
   * don
   * university
   * ca
   * michael
   * uiuc
   * john
   * post
   * cc
   * ** Parent node ***
   * No parent
   * ** Child nodes ***
   * Child 1 :Index 21 Count 5245.599784
   * david
   * st
   * kevin
   * wpi
   * koresh
   * tim
   * stephen
   * ray
   * fbi
   * president
   * Child 2 :Index 22 Count 4.257649
   * speed
   * cars
   * craig
   * america
   * built
   * higher
   * account
   * clear
   * lot
   * guess
   *
   */
  def readNode(lines: List[String]): Node = {
    val (current, remaining) = readTopic(lines)

    val splitIndex = remaining.indexOf("*** Child nodes ***")
    val (parentLines, childLines) = {
      val (l1, l2) = remaining.splitAt(splitIndex)
      // first line is "*** Parent node ***" or "*** Child nodes ***"
      (l1.drop(1), l2.drop(1))
    }

    /**
     * Reads the parent/child nodes one by one.
     */
    @tailrec
    def readRelatedTopics(relation: String,
      topics: List[TopicBase], lines: List[String]): List[TopicBase] = {
      if (lines.size == 0)
        topics.reverse
      else if (lines.head == "No " + relation)
        readRelatedTopics(relation, topics, lines.tail)
      else {
        val (topic, remaining) = readTopic(lines)
        readRelatedTopics(relation, topic :: topics, remaining)
      }
    }

    val parent = readRelatedTopics("parent", List.empty, parentLines) match {
      case t :: Nil => Some(t.index)
      case Nil => None
      case _@ l => throw new IllegalArgumentException(l.toString())
    }

    val children = readRelatedTopics("children", List.empty, childLines)

    Node(current, parent, children.map(_.index))
  }

  /**
   * Reads a topic defined by keywords.  Returns the topic and the
   * remaining lines.  A topic is defined as below:
   *
   * Child 2 :Index 22 Count 4.257649
   *  speed
   *  cars
   *  craig
   *  america
   *  built
   *  higher
   *  account
   *  clear
   *  lot
   *  guess
   *
   */
  def readTopic(lines: List[String]): (TopicBase, List[String]) = {
    val nodeLineRegex(index, count) = lines.head

    // drop the first line
    val (wordLines, otherLines) = lines.tail.span { _.startsWith("\t") }
    val keywords = wordLines.map { _.trim }.toVector
    (TopicBase(index.toInt, count.toDouble, keywords), otherLines)
  }

  def buildTree(node: Node, childrenMap: Map[Int, List[Node]]): Tree[TopicBase] = {
    val children =
      childrenMap.getOrElse(node.topic.index, List.empty)
        .map(buildTree(_, childrenMap))

    Tree.node(node.topic, children)
  }
}

